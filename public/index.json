[{"content":"","date":"9 março 2024","permalink":"/","section":"","summary":"","title":""},{"content":"package posts\n","date":"9 março 2024","permalink":"/posts/","section":"","summary":"package posts","title":""},{"content":"The Builder Design Pattern is used when the object you need to create requires more complex logic to be instantiated.\nTake a Email object as an example - you have multiple properties that need to be defined: title, message, importance status, cc, who sent it, etc.\nThis is a traditional approach:\nclass MailBuilder { private var to: List\u0026lt;String\u0026gt; = listOf() private var cc: List\u0026lt;String\u0026gt; = listOf() private var title: String = \u0026#34;\u0026#34; private var message: String = \u0026#34;\u0026#34; private var important: Boolean = false class Mail internal constructor( val to: List\u0026lt;String\u0026gt;, val cc: List\u0026lt;String\u0026gt;?, val title: String?, val message: String?, val important: Boolean ) // For each property, create a similar function to set it fun to(to: List\u0026lt;String\u0026gt;): MailBuilder { this.to = to return this } fun message(message: String): MailBuilder { this.message = message return this } fun build(): Mail { if (to.isEmpty()) { throw RuntimeException(\u0026#34;To property is empty!\u0026#34;) } return Mail(to, cc, title, message, important) } } // Then you can create Mail objects like this: fun foo(): MailBuilder.Mail { return MailBuilder() .message(\u0026#34;message\u0026#34;) .to(listOf(\u0026#34;rabbit@victor.com\u0026#34;)) .build() } Create a Builder function that has private mutable properties that are manipulated internally via functions such as message() and to(). The syntax becomes much clearer.\nIn Kotlin, however, you don\u0026rsquo;t really need to use the Builder Pattern because there are language features that let you instantiate complex objects using [[data class]] objects and [[Scope Functions]] if needed.\n/*This is what is possible using Kotlin Standard Library, basically removing the need for all the boilerplate*/ // Settings default arguments you are able to skip properties that are not needed during the object creation data class Mail_V2( val to: List\u0026lt;String\u0026gt;, val cc: List\u0026lt;String\u0026gt; = listOf(), val title: String = \u0026#34;\u0026#34;, val message: String = \u0026#34;\u0026#34;, val important: Boolean = false, ) // you have named arguments in Kotlin val mail = Mail_V2( title = \u0026#34;This is a Title\u0026#34;, message = \u0026#34;This is a message body\u0026#34;, to = listOf(\u0026#34;rabbit@victor.com\u0026#34;) ) ","date":"9 março 2024","permalink":"/posts/hello-world/","section":"","summary":"The Builder Design Pattern is used when the object you need to create requires more complex logic to be instantiated.","title":"Hello World!"},{"content":"Olá, meu nome é Víctor!\n","date":"1 janeiro 0001","permalink":"/about/","section":"","summary":"Olá, meu nome é Víctor!","title":""},{"content":"","date":"1 janeiro 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 janeiro 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 janeiro 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 janeiro 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]